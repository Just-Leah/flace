--[[
json.lua
Copyright (c) 2020 rxi
	Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
	The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
]]
--at https://github.com/rxi/json.lua --
local json = { _version = "0.1.2" }
local a;local b={["\\"]="\\",["\""]="\"",["\b"]="b",["\f"]="f",["\n"]="n",["\r"]="r",["\t"]="t"}local c={["/"]="/"}for d,e in pairs(b)do c[e]=d end;local function f(g)return"\\"..(b[g]or string.format("u%04x",g:byte()))end;local function h(i)return"null"end;local function j(i,k)local l={}k=k or{}if k[i]then error("circular reference")end;k[i]=true;if rawget(i,1)~=nil or next(i)==nil then local m=0;for d in pairs(i)do if type(d)~="number"then error("invalid table: mixed or invalid key types")end;m=m+1 end;if m~=#i then error("invalid table: sparse array")end;for n,e in ipairs(i)do table.insert(l,a(e,k))end;k[i]=nil;return"["..table.concat(l,",").."]"else for d,e in pairs(i)do if type(d)~="string"then error("invalid table: mixed or invalid key types")end;table.insert(l,a(d,k)..":"..a(e,k))end;k[i]=nil;return"{"..table.concat(l,",").."}"end end;local function o(i)return'"'..i:gsub('[%z\1-\31\\"]',f)..'"'end;local function p(i)if i~=i or i<=-math.huge or i>=math.huge then error("unexpected number value '"..tostring(i).."'")end;return string.format("%.14g",i)end;local q={["nil"]=h,["table"]=j,["string"]=o,["number"]=p,["boolean"]=tostring}a=function(i,k)local r=type(i)local s=q[r]if s then return s(i,k)end;error("unexpected type '"..r.."'")end;function json.encode(i)return a(i)end;local t;local function u(...)local l={}for n=1,select("#",...)do l[select(n,...)]=true end;return l end;local v=u(" ","\t","\r","\n")local w=u(" ","\t","\r","\n","]","}",",")local x=u("\\","/",'"',"b","f","n","r","t","u")local y=u("true","false","null")local z={["true"]=true,["false"]=false,["null"]=nil}local function A(B,C,D,E)for n=C,#B do if D[B:sub(n,n)]~=E then return n end end;return#B+1 end;local function F(B,C,G)local H=1;local I=1;for n=1,C-1 do I=I+1;if B:sub(n,n)=="\n"then H=H+1;I=1 end end;error(string.format("%s at line %d col %d",G,H,I))end;local function J(m)local s=math.floor;if m<=0x7f then return string.char(m)elseif m<=0x7ff then return string.char(s(m/64)+192,m%64+128)elseif m<=0xffff then return string.char(s(m/4096)+224,s(m%4096/64)+128,m%64+128)elseif m<=0x10ffff then return string.char(s(m/262144)+240,s(m%262144/4096)+128,s(m%4096/64)+128,m%64+128)end;error(string.format("invalid unicode codepoint '%x'",m))end;local function K(L)local M=tonumber(L:sub(1,4),16)local N=tonumber(L:sub(7,10),16)if N then return J((M-0xd800)*0x400+N-0xdc00+0x10000)else return J(M)end end;local function O(B,n)local l=""local P=n+1;local d=P;while P<=#B do local Q=B:byte(P)if Q<32 then F(B,P,"control character in string")elseif Q==92 then l=l..B:sub(d,P-1)P=P+1;local g=B:sub(P,P)if g=="u"then local R=B:match("^[dD][89aAbB]%x%x\\u%x%x%x%x",P+1)or B:match("^%x%x%x%x",P+1)or F(B,P-1,"invalid unicode escape in string")l=l..K(R)P=P+#R else if not x[g]then F(B,P-1,"invalid escape char '"..g.."' in string")end;l=l..c[g]end;d=P+1 elseif Q==34 then l=l..B:sub(d,P-1)return l,P+1 end;P=P+1 end;F(B,n,"expected closing quote for string")end;local function S(B,n)local Q=A(B,n,w)local L=B:sub(n,Q-1)local m=tonumber(L)if not m then F(B,n,"invalid number '"..L.."'")end;return m,Q end;local function T(B,n)local Q=A(B,n,w)local U=B:sub(n,Q-1)if not y[U]then F(B,n,"invalid literal '"..U.."'")end;return z[U],Q end;local function V(B,n)local l={}local m=1;n=n+1;while 1 do local Q;n=A(B,n,v,true)if B:sub(n,n)=="]"then n=n+1;break end;Q,n=t(B,n)l[m]=Q;m=m+1;n=A(B,n,v,true)local W=B:sub(n,n)n=n+1;if W=="]"then break end;if W~=","then F(B,n,"expected ']' or ','")end end;return l,n end;local function X(B,n)local l={}n=n+1;while 1 do local Y,i;n=A(B,n,v,true)if B:sub(n,n)=="}"then n=n+1;break end;if B:sub(n,n)~='"'then F(B,n,"expected string for key")end;Y,n=t(B,n)n=A(B,n,v,true)if B:sub(n,n)~=":"then F(B,n,"expected ':' after key")end;n=A(B,n+1,v,true)i,n=t(B,n)l[Y]=i;n=A(B,n,v,true)local W=B:sub(n,n)n=n+1;if W=="}"then break end;if W~=","then F(B,n,"expected '}' or ','")end end;return l,n end;local Z={['"']=O,["0"]=S,["1"]=S,["2"]=S,["3"]=S,["4"]=S,["5"]=S,["6"]=S,["7"]=S,["8"]=S,["9"]=S,["-"]=S,["t"]=T,["f"]=T,["n"]=T,["["]=V,["{"]=X}t=function(B,C)local W=B:sub(C,C)local s=Z[W]if s then return s(B,C)end;F(B,C,"unexpected character '"..W.."'")end;function json.decode(B)if type(B)~="string"then error("expected argument of type string, got "..type(B))end;local l,C=t(B,A(B,1,v,true))C=A(B,C,v,true)if C<=#B then F(B,C,"trailing garbage")end;return l end;return json
